#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RĀHIRI 2.0 - Cyber-Organic Visual Being System
Complete Edition - Bug-Free & Ready to Play

A mesmerizing interactive simulation where you guide a living digital entity.
Your presence is felt through the arrow keys, and the entity responds to your will.

Controls:
    ↑ ↓ ← → : Guide the entity with arrow keys
    
The cyan diamond is YOU - your avatar in this digital space.
The particle swarm is RĀHIRI - a cyber-organic being that senses your presence.

Author: Claude (Anthropic)
Version: 2.0 Complete Edition
"""

import numpy as np
import math
import random
import sys
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.patches import RegularPolygon, Circle, FancyArrowPatch
from matplotlib.collections import LineCollection
from typing import Dict, List, Tuple, Optional, Any
from collections import deque
from dataclasses import dataclass, field
import warnings
warnings.filterwarnings('ignore')

# =============================================================================
# CONFIGURATION
# =============================================================================

plt.rcParams['toolbar'] = 'None'
plt.rcParams['figure.facecolor'] = '#0a0a0f'
plt.rcParams['axes.facecolor'] = '#0a0a0f'


@dataclass
class Config:
    """System configuration parameters"""
    # World dimensions
    world_width: float = 100.0
    world_height: float = 100.0
    
    # Particle system
    n_particles: int = 50
    particle_size_base: float = 60.0
    particle_size_variance: float = 40.0
    
    # Physics
    max_particle_speed: float = 1.8
    max_user_speed: float = 2.5
    velocity_damping: float = 0.92
    
    # Flocking behavior
    cohesion_weight: float = 0.012
    alignment_weight: float = 0.008
    separation_weight: float = 0.025
    separation_radius: float = 8.0
    
    # User influence
    user_attraction_weight: float = 0.15
    user_attraction_radius: float = 50.0
    resonance_growth_rate: float = 0.02
    resonance_decay_rate: float = 0.005
    
    # Visual
    connection_max_distance: float = 20.0
    connection_alpha: float = 0.25
    trail_length: int = 15
    
    # Timing
    frame_interval: int = 33  # ~30 FPS


@dataclass  
class DNA:
    """Genetic traits defining personality"""
    curiosity: float = 0.8
    sensitivity: float = 0.85
    creativity: float = 0.7
    sociability: float = 0.6
    energy_base: float = 0.9


# =============================================================================
# EMOTIONAL SYSTEM
# =============================================================================

class EmotionalCore:
    """Manages the emotional state of the entity"""
    
    def __init__(self, dna: DNA):
        self.dna = dna
        
        # Core emotions with their properties
        self.emotions = {
            'joy': {'value': 0.5, 'decay': 0.995, 'color': '#FFD700'},
            'curiosity': {'value': 0.7, 'decay': 0.990, 'color': '#00CED1'},
            'excitement': {'value': 0.3, 'decay': 0.985, 'color': '#FF6B6B'},
            'calm': {'value': 0.6, 'decay': 0.998, 'color': '#98FB98'},
            'wonder': {'value': 0.4, 'decay': 0.992, 'color': '#DDA0DD'},
        }
        
        # Emotional momentum for smooth transitions
        self.momentum = {name: 0.0 for name in self.emotions}
        
    def update(self, user_proximity: float, user_activity: float, 
               swarm_coherence: float) -> Dict[str, float]:
        """Update emotional state based on inputs"""
        
        # Calculate stimulation levels
        proximity_factor = max(0, 1 - user_proximity / 50)
        
        # Update each emotion
        for name, emotion in self.emotions.items():
            # Natural decay
            emotion['value'] *= emotion['decay']
            
            # Stimulation based on context
            if name == 'joy':
                stimulus = proximity_factor * 0.02 * self.dna.sensitivity
            elif name == 'curiosity':
                stimulus = user_activity * 0.03 * self.dna.curiosity
            elif name == 'excitement':
                stimulus = (user_activity + proximity_factor) * 0.015
            elif name == 'calm':
                stimulus = (1 - user_activity) * swarm_coherence * 0.01
            elif name == 'wonder':
                stimulus = proximity_factor * user_activity * 0.02
            else:
                stimulus = 0
            
            # Apply with momentum for smoothness
            self.momentum[name] = 0.9 * self.momentum[name] + 0.1 * stimulus
            emotion['value'] = np.clip(
                emotion['value'] + self.momentum[name], 
                0.05, 1.0
            )
        
        return {name: e['value'] for name, e in self.emotions.items()}
    
    def get_dominant_emotion(self) -> Tuple[str, float]:
        """Get the strongest current emotion"""
        name, data = max(self.emotions.items(), key=lambda x: x[1]['value'])
        return (name, data['value'])
    
    def get_color_blend(self) -> str:
        """Get a color representing the current emotional state"""
        # Weighted average of emotion colors
        total_weight = sum(e['value'] for e in self.emotions.values())
        if total_weight == 0:
            return '#FFFFFF'
        
        r, g, b = 0, 0, 0
        for emotion in self.emotions.values():
            weight = emotion['value'] / total_weight
            color = emotion['color'].lstrip('#')
            r += int(color[0:2], 16) * weight
            g += int(color[2:4], 16) * weight
            b += int(color[4:6], 16) * weight
        
        return f'#{int(r):02x}{int(g):02x}{int(b):02x}'


# =============================================================================
# CONSCIOUSNESS LAYER
# =============================================================================

class ConsciousnessLayer:
    """Generates narrative experience and intention"""
    
    def __init__(self):
        self.narratives = {
            'greeting': [
                "I sense your presence...",
                "You have arrived.",
                "Welcome to my realm.",
                "I feel you near.",
            ],
            'connection': [
                "We move as one.",
                "Our paths intertwine.",
                "I follow your light.",
                "Together we dance.",
                "Your will guides me.",
            ],
            'wonder': [
                "What mysteries do you bring?",
                "Show me new patterns.",
                "Where shall we explore?",
                "The unknown beckons.",
            ],
            'joy': [
                "This brings me joy.",
                "Harmony flows through us.",
                "I am content.",
                "Peace in motion.",
            ],
            'excitement': [
                "Energy surges!",
                "The dance intensifies!",
                "Faster, together!",
                "Exhilarating!",
            ],
            'calm': [
                "Stillness has beauty.",
                "I rest in your presence.",
                "Tranquil moments.",
                "Serenity.",
            ],
        }
        
        self.current_narrative = "Awakening..."
        self.narrative_cooldown = 0
        self.last_theme = None
        
    def update(self, emotions: Dict[str, float], resonance: float, 
               time_active: float) -> str:
        """Generate contextual narrative"""
        
        self.narrative_cooldown -= 1
        
        if self.narrative_cooldown > 0:
            return self.current_narrative
        
        # Determine theme based on state
        if time_active < 2.0:
            theme = 'greeting'
        elif resonance > 0.7:
            theme = 'connection'
        else:
            # Pick based on dominant emotion
            dominant = max(emotions.items(), key=lambda x: x[1])
            emotion_map = {
                'joy': 'joy',
                'curiosity': 'wonder', 
                'excitement': 'excitement',
                'calm': 'calm',
                'wonder': 'wonder',
            }
            theme = emotion_map.get(dominant[0], 'connection')
        
        # Select narrative avoiding immediate repetition
        options = self.narratives[theme]
        if theme == self.last_theme and len(options) > 1:
            options = [n for n in options if n != self.current_narrative]
        
        self.current_narrative = random.choice(options)
        self.last_theme = theme
        self.narrative_cooldown = random.randint(90, 180)  # 3-6 seconds
        
        return self.current_narrative


# =============================================================================
# ENERGY SYSTEM
# =============================================================================

class EnergySystem:
    """Manages vitality and metabolism"""
    
    def __init__(self, dna: DNA):
        self.vitality = dna.energy_base
        self.stamina = 1.0
        self.metabolism = 0.5 + dna.creativity * 0.3
        
        self.history = deque(maxlen=100)
        
    def update(self, activity_level: float) -> Dict[str, float]:
        """Update energy based on activity"""
        
        # Energy cost scales with activity
        cost = activity_level * 0.0003 * self.metabolism
        
        # Natural regeneration
        regen = 0.0005 * (1 + (1 - activity_level) * 0.5)
        
        # Update vitality
        self.vitality = np.clip(self.vitality - cost + regen, 0.3, 1.0)
        
        # Stamina recovers when calm
        if activity_level < 0.2:
            self.stamina = min(1.0, self.stamina + 0.002)
        else:
            self.stamina = max(0.4, self.stamina - activity_level * 0.0005)
        
        self.history.append(self.vitality)
        
        return {
            'vitality': self.vitality,
            'stamina': self.stamina,
            'metabolism': self.metabolism,
        }


# =============================================================================
# USER AVATAR
# =============================================================================

class UserAvatar:
    """The player's representation in the digital world"""
    
    def __init__(self, config: Config):
        self.config = config
        
        # Position at world center
        self.position = np.array([
            config.world_width / 2,
            config.world_height / 2
        ], dtype=np.float64)
        
        self.velocity = np.array([0.0, 0.0])
        self.acceleration = np.array([0.0, 0.0])
        
        # Visual properties
        self.size = 12.0
        self.color = '#00FFFF'  # Cyan
        self.glow_phase = 0.0
        
        # Trail for visual effect
        self.trail = deque(maxlen=config.trail_length)
        
        # Input state
        self.input_direction = np.array([0.0, 0.0])
        
    def set_input(self, dx: float, dy: float):
        """Set movement direction from keyboard input"""
        self.input_direction = np.array([dx, dy], dtype=np.float64)
        
        # Normalize if diagonal
        magnitude = np.linalg.norm(self.input_direction)
        if magnitude > 1.0:
            self.input_direction /= magnitude
    
    def update(self) -> np.ndarray:
        """Update position based on input"""
        
        # Apply input as acceleration
        self.acceleration = self.input_direction * 0.3
        
        # Update velocity with damping
        self.velocity = self.velocity * 0.85 + self.acceleration
        
        # Limit speed
        speed = np.linalg.norm(self.velocity)
        if speed > self.config.max_user_speed:
            self.velocity = self.velocity / speed * self.config.max_user_speed
        
        # Update position
        self.position += self.velocity
        
        # Boundary wrapping (toroidal world)
        self.position[0] = self.position[0] % self.config.world_width
        self.position[1] = self.position[1] % self.config.world_height
        
        # Update trail
        self.trail.append(self.position.copy())
        
        # Update glow animation
        self.glow_phase = (self.glow_phase + 0.1) % (2 * np.pi)
        
        return self.position
    
    def get_activity_level(self) -> float:
        """Return normalized activity level"""
        return np.linalg.norm(self.velocity) / self.config.max_user_speed


# =============================================================================
# PARTICLE SWARM
# =============================================================================

class ParticleSwarm:
    """The cyber-organic entity - a swarm of interconnected particles"""
    
    def __init__(self, config: Config, dna: DNA):
        self.config = config
        self.dna = dna
        self.n = config.n_particles
        
        # Initialize positions in a circular pattern around center
        self.positions = self._init_positions()
        self.velocities = np.random.randn(self.n, 2) * 0.1
        
        # Per-particle properties
        self.energies = np.random.uniform(0.5, 1.0, self.n)
        self.phases = np.random.uniform(0, 2 * np.pi, self.n)  # For animation
        
        # Swarm state
        self.center_of_mass = self.positions.mean(axis=0)
        self.coherence = 0.5
        
    def _init_positions(self) -> np.ndarray:
        """Initialize particles in an organic pattern"""
        positions = []
        center = np.array([self.config.world_width / 2, 
                          self.config.world_height / 2])
        
        # Core cluster
        for i in range(self.n // 2):
            angle = i * 2 * np.pi / (self.n // 2)
            radius = 8 + np.random.randn() * 2
            pos = center + radius * np.array([np.cos(angle), np.sin(angle)])
            positions.append(pos)
        
        # Outer satellites
        for i in range(self.n // 2, self.n):
            angle = np.random.uniform(0, 2 * np.pi)
            radius = 15 + np.random.randn() * 5
            pos = center + radius * np.array([np.cos(angle), np.sin(angle)])
            positions.append(pos)
        
        return np.array(positions, dtype=np.float64)
    
    def update(self, user_pos: np.ndarray, resonance: float, 
               vitality: float) -> Dict[str, Any]:
        """Update all particles for one timestep"""
        
        # Calculate forces
        cohesion = self._calc_cohesion()
        alignment = self._calc_alignment()
        separation = self._calc_separation()
        user_attraction = self._calc_user_attraction(user_pos, resonance)
        
        # Combine forces
        total_force = (
            cohesion * self.config.cohesion_weight +
            alignment * self.config.alignment_weight +
            separation * self.config.separation_weight +
            user_attraction * self.config.user_attraction_weight
        )
        
        # Scale by vitality
        total_force *= vitality
        
        # Update velocities
        self.velocities = self.velocities * self.config.velocity_damping + total_force
        
        # Limit speed
        speeds = np.linalg.norm(self.velocities, axis=1, keepdims=True)
        speeds = np.clip(speeds, 0.001, None)  # Avoid division by zero
        max_speed = self.config.max_particle_speed * vitality
        self.velocities = np.where(
            speeds > max_speed,
            self.velocities / speeds * max_speed,
            self.velocities
        )
        
        # Update positions
        self.positions += self.velocities
        
        # Soft boundary (particles are gently pushed back)
        self._apply_boundaries()
        
        # Update state metrics
        self.center_of_mass = self.positions.mean(axis=0)
        self.coherence = self._calc_coherence()
        
        # Update animation phases
        self.phases = (self.phases + 0.05 + speeds.flatten() * 0.1) % (2 * np.pi)
        
        # Update per-particle energy
        self.energies = 0.99 * self.energies + 0.01 * (0.5 + speeds.flatten() / max_speed * 0.5)
        
        return {
            'positions': self.positions.copy(),
            'velocities': self.velocities.copy(),
            'speeds': speeds.flatten(),
            'energies': self.energies.copy(),
            'phases': self.phases.copy(),
            'center': self.center_of_mass.copy(),
            'coherence': self.coherence,
        }
    
    def _calc_cohesion(self) -> np.ndarray:
        """Attraction toward center of mass"""
        return self.center_of_mass - self.positions
    
    def _calc_alignment(self) -> np.ndarray:
        """Alignment with average velocity"""
        mean_vel = self.velocities.mean(axis=0)
        return np.tile(mean_vel, (self.n, 1)) - self.velocities
    
    def _calc_separation(self) -> np.ndarray:
        """Repulsion from nearby particles"""
        separation = np.zeros_like(self.positions)
        
        for i in range(self.n):
            diff = self.positions[i] - self.positions
            dist = np.linalg.norm(diff, axis=1)
            
            # Find neighbors too close
            mask = (dist < self.config.separation_radius) & (dist > 0)
            if mask.any():
                # Weighted repulsion (stronger when closer)
                weights = 1.0 / (dist[mask] + 0.1)
                separation[i] = (diff[mask] * weights[:, np.newaxis]).sum(axis=0)
        
        return separation
    
    def _calc_user_attraction(self, user_pos: np.ndarray, 
                              resonance: float) -> np.ndarray:
        """Attraction toward user position, modulated by resonance"""
        
        diff = user_pos - self.positions
        distances = np.linalg.norm(diff, axis=1, keepdims=True)
        distances = np.clip(distances, 0.1, None)
        
        # Normalize direction
        direction = diff / distances
        
        # Strength falls off with distance, amplified by resonance
        strength = (1 - distances / self.config.user_attraction_radius)
        strength = np.clip(strength, 0, 1)
        strength *= (0.5 + resonance * 0.5)  # Resonance amplifies attraction
        
        return direction * strength
    
    def _calc_coherence(self) -> float:
        """Calculate how tightly grouped the swarm is"""
        distances = np.linalg.norm(self.positions - self.center_of_mass, axis=1)
        avg_dist = distances.mean()
        # Normalize to 0-1 range (smaller distance = higher coherence)
        return np.clip(1 - avg_dist / 30, 0, 1)
    
    def _apply_boundaries(self):
        """Soft boundary conditions"""
        margin = 5
        force_strength = 0.5
        
        # Left/Right
        mask_left = self.positions[:, 0] < margin
        mask_right = self.positions[:, 0] > self.config.world_width - margin
        self.velocities[mask_left, 0] += force_strength
        self.velocities[mask_right, 0] -= force_strength
        
        # Top/Bottom
        mask_bottom = self.positions[:, 1] < margin
        mask_top = self.positions[:, 1] > self.config.world_height - margin
        self.velocities[mask_bottom, 1] += force_strength
        self.velocities[mask_top, 1] -= force_strength
        
        # Hard clamp as backup
        self.positions[:, 0] = np.clip(self.positions[:, 0], 1, self.config.world_width - 1)
        self.positions[:, 1] = np.clip(self.positions[:, 1], 1, self.config.world_height - 1)


# =============================================================================
# RESONANCE SYSTEM
# =============================================================================

class ResonanceSystem:
    """Tracks the connection strength between user and entity"""
    
    def __init__(self, config: Config):
        self.config = config
        self.level = 0.0
        self.history = deque(maxlen=100)
        
    def update(self, user_pos: np.ndarray, swarm_center: np.ndarray,
               user_active: bool) -> float:
        """Update resonance level based on proximity and activity"""
        
        # Distance between user and swarm center
        distance = np.linalg.norm(user_pos - swarm_center)
        proximity = max(0, 1 - distance / self.config.user_attraction_radius)
        
        # Resonance grows when close and user is active
        if user_active and proximity > 0.3:
            growth = proximity * self.config.resonance_growth_rate
            self.level = min(1.0, self.level + growth)
        else:
            # Decay when not engaged
            self.level = max(0.0, self.level - self.config.resonance_decay_rate)
        
        self.history.append(self.level)
        return self.level


# =============================================================================
# MAIN ENGINE
# =============================================================================

class RahiriEngine:
    """Main simulation engine orchestrating all systems"""
    
    def __init__(self):
        self.config = Config()
        self.dna = DNA()
        
        # Core systems
        self.user = UserAvatar(self.config)
        self.swarm = ParticleSwarm(self.config, self.dna)
        self.emotions = EmotionalCore(self.dna)
        self.consciousness = ConsciousnessLayer()
        self.energy = EnergySystem(self.dna)
        self.resonance = ResonanceSystem(self.config)
        
        # State tracking
        self.time = 0.0
        self.frame = 0
        
        print("[ENGINE] RĀHIRI 2.0 initialized")
        print(f"[CONFIG] {self.config.n_particles} particles")
        print(f"[DNA] Curiosity: {self.dna.curiosity:.2f}, "
              f"Sensitivity: {self.dna.sensitivity:.2f}")
    
    def set_user_input(self, dx: float, dy: float):
        """Pass input to user avatar"""
        self.user.set_input(dx, dy)
    
    def step(self) -> Tuple[Dict, Dict]:
        """Execute one simulation step"""
        self.time += 0.033
        self.frame += 1
        
        # 1. Update user position
        user_pos = self.user.update()
        user_activity = self.user.get_activity_level()
        
        # 2. Update resonance
        resonance_level = self.resonance.update(
            user_pos, 
            self.swarm.center_of_mass,
            user_activity > 0.1
        )
        
        # 3. Update energy
        combined_activity = (user_activity + np.mean(
            np.linalg.norm(self.swarm.velocities, axis=1)
        ) / self.config.max_particle_speed) / 2
        energy_state = self.energy.update(combined_activity)
        
        # 4. Update swarm
        swarm_data = self.swarm.update(
            user_pos, 
            resonance_level, 
            energy_state['vitality']
        )
        
        # 5. Update emotions
        user_dist = np.linalg.norm(user_pos - swarm_data['center'])
        emotion_values = self.emotions.update(
            user_dist,
            user_activity,
            swarm_data['coherence']
        )
        
        # 6. Update consciousness
        narrative = self.consciousness.update(
            emotion_values,
            resonance_level,
            self.time
        )
        
        # Compile output
        particle_data = {
            'positions': swarm_data['positions'],
            'velocities': swarm_data['velocities'],
            'speeds': swarm_data['speeds'],
            'energies': swarm_data['energies'],
            'phases': swarm_data['phases'],
            'center': swarm_data['center'],
        }
        
        system_data = {
            'user_position': user_pos.copy(),
            'user_velocity': self.user.velocity.copy(),
            'user_trail': list(self.user.trail),
            'user_glow_phase': self.user.glow_phase,
            'resonance': resonance_level,
            'resonance_history': list(self.resonance.history),
            'emotions': emotion_values,
            'emotion_color': self.emotions.get_color_blend(),
            'dominant_emotion': self.emotions.get_dominant_emotion(),
            'energy': energy_state,
            'energy_history': list(self.energy.history),
            'narrative': narrative,
            'coherence': swarm_data['coherence'],
            'time': self.time,
            'frame': self.frame,
        }
        
        return particle_data, system_data


# =============================================================================
# VISUALIZER
# =============================================================================

class Visualizer:
    """Real-time visualization system"""
    
    def __init__(self, engine: RahiriEngine):
        self.engine = engine
        self.config = engine.config
        
        # Create figure with subplots
        self.fig = plt.figure(figsize=(14, 9), facecolor='#0a0a0f')
        self.fig.canvas.manager.set_window_title(
            'RĀHIRI 2.0 - Cyber-Organic Being [Arrow Keys to Interact]'
        )
        
        # Main view takes most space
        self.ax_main = self.fig.add_axes([0.05, 0.15, 0.65, 0.80])
        
        # Side panels
        self.ax_emotions = self.fig.add_axes([0.73, 0.55, 0.24, 0.40])
        self.ax_resonance = self.fig.add_axes([0.73, 0.15, 0.24, 0.35])
        
        # Bottom panel for narrative
        self.ax_narrative = self.fig.add_axes([0.05, 0.02, 0.65, 0.10])
        
        self._setup_axes()
        self._init_visual_elements()
        self._setup_input()
        
        # Input state
        self.keys_pressed = {'up': False, 'down': False, 'left': False, 'right': False}
        
        print("[VISUALIZER] Ready")
    
    def _setup_axes(self):
        """Configure all axes"""
        # Main view
        self.ax_main.set_xlim(0, self.config.world_width)
        self.ax_main.set_ylim(0, self.config.world_height)
        self.ax_main.set_facecolor('#0a0a0f')
        self.ax_main.set_xticks([])
        self.ax_main.set_yticks([])
        self.ax_main.set_aspect('equal')
        for spine in self.ax_main.spines.values():
            spine.set_color('#1a1a2e')
            spine.set_linewidth(2)
        
        # Emotions panel
        self.ax_emotions.set_facecolor('#0a0a0f')
        self.ax_emotions.set_xlim(0, 1)
        self.ax_emotions.set_ylim(-0.5, 4.5)
        self.ax_emotions.set_xticks([])
        self.ax_emotions.set_yticks([])
        self.ax_emotions.set_title('EMOTIONAL STATE', color='white', 
                                   fontsize=10, fontweight='bold', pad=10)
        for spine in self.ax_emotions.spines.values():
            spine.set_color('#1a1a2e')
        
        # Resonance panel
        self.ax_resonance.set_facecolor('#0a0a0f')
        self.ax_resonance.set_xlim(0, 100)
        self.ax_resonance.set_ylim(0, 1)
        self.ax_resonance.set_xticks([])
        self.ax_resonance.set_yticks([0, 0.5, 1])
        self.ax_resonance.tick_params(colors='#666666', labelsize=8)
        self.ax_resonance.set_title('RESONANCE', color='white', 
                                    fontsize=10, fontweight='bold', pad=10)
        for spine in self.ax_resonance.spines.values():
            spine.set_color('#1a1a2e')
        
        # Narrative panel
        self.ax_narrative.set_facecolor('#0a0a0f')
        self.ax_narrative.set_xlim(0, 1)
        self.ax_narrative.set_ylim(0, 1)
        self.ax_narrative.set_xticks([])
        self.ax_narrative.set_yticks([])
        for spine in self.ax_narrative.spines.values():
            spine.set_visible(False)
    
    def _init_visual_elements(self):
        """Initialize all visual elements"""
        
        # Particle scatter
        self.particle_scatter = self.ax_main.scatter(
            [], [], s=60, c=[], cmap='plasma', 
            alpha=0.85, edgecolors='white', linewidths=0.3
        )
        
        # Particle connections (will be updated as LineCollection)
        self.connections = LineCollection([], colors='white', 
                                          linewidths=0.5, alpha=0.15)
        self.ax_main.add_collection(self.connections)
        
        # User avatar - diamond shape
        self.user_marker = self.ax_main.scatter(
            [50], [50], s=200, c='#00FFFF', marker='D',
            edgecolors='white', linewidths=2, zorder=100
        )
        
        # User glow effect
        self.user_glow = self.ax_main.scatter(
            [50], [50], s=400, c='#00FFFF', marker='o',
            alpha=0.2, zorder=99
        )
        
        # User trail
        self.trail_line, = self.ax_main.plot(
            [], [], color='#00FFFF', alpha=0.3, linewidth=2
        )
        
        # Connection line from user to swarm center
        self.connection_beam, = self.ax_main.plot(
            [], [], color='#00FFFF', alpha=0.0, linewidth=1,
            linestyle='--'
        )
        
        # Emotion bars
        self.emotion_bars = []
        self.emotion_labels = []
        emotions = ['Joy', 'Curiosity', 'Excitement', 'Calm', 'Wonder']
        colors = ['#FFD700', '#00CED1', '#FF6B6B', '#98FB98', '#DDA0DD']
        
        for i, (name, color) in enumerate(zip(emotions, colors)):
            bar = self.ax_emotions.barh(i, 0, height=0.6, color=color, alpha=0.8)
            self.emotion_bars.append(bar[0])
            label = self.ax_emotions.text(
                -0.05, i, name, ha='right', va='center',
                color='white', fontsize=9, fontweight='bold'
            )
            self.emotion_labels.append(label)
        
        # Resonance line
        self.resonance_line, = self.ax_resonance.plot(
            [], [], color='#00FFFF', linewidth=2, alpha=0.8
        )
        self.resonance_fill = None
        
        # Resonance level text
        self.resonance_text = self.ax_resonance.text(
            95, 0.9, '0%', ha='right', va='top',
            color='#00FFFF', fontsize=14, fontweight='bold'
        )
        
        # Narrative text
        self.narrative_text = self.ax_narrative.text(
            0.5, 0.5, '', ha='center', va='center',
            color='white', fontsize=14, fontfamily='monospace',
            style='italic'
        )
        
        # Title and stats
        self.title_text = self.ax_main.text(
            0.5, 1.02, 'RĀHIRI', transform=self.ax_main.transAxes,
            ha='center', va='bottom', color='white',
            fontsize=16, fontweight='bold'
        )
        
        self.stats_text = self.ax_main.text(
            0.02, 0.98, '', transform=self.ax_main.transAxes,
            ha='left', va='top', color='#888888',
            fontsize=8, fontfamily='monospace'
        )
        
        # Instructions
        self.instructions = self.ax_main.text(
            0.98, 0.02, '↑↓←→ to guide',
            transform=self.ax_main.transAxes,
            ha='right', va='bottom', color='#444444',
            fontsize=8
        )
    
    def _setup_input(self):
        """Setup keyboard input handling"""
        self.fig.canvas.mpl_connect('key_press_event', self._on_key_press)
        self.fig.canvas.mpl_connect('key_release_event', self._on_key_release)
    
    def _on_key_press(self, event):
        """Handle key press"""
        if event.key == 'up':
            self.keys_pressed['up'] = True
        elif event.key == 'down':
            self.keys_pressed['down'] = True
        elif event.key == 'left':
            self.keys_pressed['left'] = True
        elif event.key == 'right':
            self.keys_pressed['right'] = True
        elif event.key == 'escape':
            plt.close(self.fig)
    
    def _on_key_release(self, event):
        """Handle key release"""
        if event.key == 'up':
            self.keys_pressed['up'] = False
        elif event.key == 'down':
            self.keys_pressed['down'] = False
        elif event.key == 'left':
            self.keys_pressed['left'] = False
        elif event.key == 'right':
            self.keys_pressed['right'] = False
    
    def _get_input_vector(self) -> Tuple[float, float]:
        """Convert key states to direction vector"""
        dx, dy = 0.0, 0.0
        if self.keys_pressed['up']:
            dy += 1.0
        if self.keys_pressed['down']:
            dy -= 1.0
        if self.keys_pressed['left']:
            dx -= 1.0
        if self.keys_pressed['right']:
            dx += 1.0
        return dx, dy
    
    def _update_particles(self, particle_data: Dict, system_data: Dict):
        """Update particle visualization"""
        positions = particle_data['positions']
        energies = particle_data['energies']
        phases = particle_data['phases']
        
        # Update positions
        self.particle_scatter.set_offsets(positions)
        
        # Dynamic sizing based on energy and phase
        sizes = self.config.particle_size_base + \
                self.config.particle_size_variance * energies * \
                (0.7 + 0.3 * np.sin(phases))
        self.particle_scatter.set_sizes(sizes)
        
        # Color based on energy and resonance
        colors = energies * (0.5 + 0.5 * system_data['resonance'])
        self.particle_scatter.set_array(colors)
        
        # Update connections
        self._update_connections(positions, system_data['resonance'])
    
    def _update_connections(self, positions: np.ndarray, resonance: float):
        """Update particle connection lines"""
        segments = []
        alphas = []
        
        threshold = self.config.connection_max_distance * (1 + resonance * 0.5)
        n = len(positions)
        
        # Sample connections for performance
        for i in range(0, n, 2):
            for j in range(i + 1, min(i + 6, n)):
                dist = np.linalg.norm(positions[i] - positions[j])
                if dist < threshold:
                    segments.append([positions[i], positions[j]])
                    alpha = self.config.connection_alpha * (1 - dist / threshold)
                    alphas.append(alpha)
        
        if segments:
            self.connections.set_segments(segments)
            self.connections.set_alpha(alphas)
        else:
            self.connections.set_segments([])
    
    def _update_user(self, system_data: Dict):
        """Update user avatar visualization"""
        pos = system_data['user_position']
        glow_phase = system_data['user_glow_phase']
        resonance = system_data['resonance']
        
        # Update position
        self.user_marker.set_offsets([pos])
        self.user_glow.set_offsets([pos])
        
        # Pulsing glow effect
        glow_size = 300 + 100 * np.sin(glow_phase) + 200 * resonance
        self.user_glow.set_sizes([glow_size])
        self.user_glow.set_alpha(0.1 + 0.15 * resonance)
        
        # Update trail
        trail = system_data['user_trail']
        if len(trail) > 1:
            trail_arr = np.array(trail)
            self.trail_line.set_data(trail_arr[:, 0], trail_arr[:, 1])
            self.trail_line.set_alpha(0.2 + 0.3 * resonance)
        
        # Connection beam to swarm (visible when resonance is high)
        if resonance > 0.3:
            center = system_data.get('center', pos)
            if 'center' not in system_data:
                # Get from particle data if available
                pass
            self.connection_beam.set_data(
                [pos[0], self.engine.swarm.center_of_mass[0]],
                [pos[1], self.engine.swarm.center_of_mass[1]]
            )
            self.connection_beam.set_alpha(resonance * 0.3)
        else:
            self.connection_beam.set_alpha(0)
    
    def _update_emotions(self, system_data: Dict):
        """Update emotion bars"""
        emotions = system_data['emotions']
        emotion_keys = ['joy', 'curiosity', 'excitement', 'calm', 'wonder']
        
        for i, key in enumerate(emotion_keys):
            value = emotions.get(key, 0)
            self.emotion_bars[i].set_width(value)
    
    def _update_resonance(self, system_data: Dict):
        """Update resonance display"""
        history = system_data['resonance_history']
        level = system_data['resonance']
        
        if history:
            x = np.arange(len(history))
            self.resonance_line.set_data(x, history)
            
            # Update fill
            if self.resonance_fill:
                self.resonance_fill.remove()
            self.resonance_fill = self.ax_resonance.fill_between(
                x, 0, history, color='#00FFFF', alpha=0.2
            )
        
        # Update percentage text
        self.resonance_text.set_text(f'{int(level * 100)}%')
    
    def _update_narrative(self, system_data: Dict):
        """Update narrative text"""
        self.narrative_text.set_text(f'"{system_data["narrative"]}"')
        
        # Color based on dominant emotion
        dominant_name, _ = system_data['dominant_emotion']
        color_map = {
            'joy': '#FFD700',
            'curiosity': '#00CED1',
            'excitement': '#FF6B6B',
            'calm': '#98FB98',
            'wonder': '#DDA0DD',
        }
        self.narrative_text.set_color(color_map.get(dominant_name, 'white'))
    
    def _update_stats(self, system_data: Dict):
        """Update statistics display"""
        energy = system_data['energy']
        stats = (
            f"Time: {system_data['time']:.1f}s | "
            f"Vitality: {int(energy['vitality']*100)}% | "
            f"Coherence: {int(system_data['coherence']*100)}%"
        )
        self.stats_text.set_text(stats)
    
    def update(self, frame: int):
        """Main update function called each frame"""
        
        # Get input
        dx, dy = self._get_input_vector()
        self.engine.set_user_input(dx, dy)
        
        # Step simulation
        particle_data, system_data = self.engine.step()
        
        # Update all visualizations
        self._update_particles(particle_data, system_data)
        self._update_user(system_data)
        self._update_emotions(system_data)
        self._update_resonance(system_data)
        self._update_narrative(system_data)
        self._update_stats(system_data)
        
        # Return artists for blitting
        return [
            self.particle_scatter,
            self.connections,
            self.user_marker,
            self.user_glow,
            self.trail_line,
            self.connection_beam,
            self.resonance_line,
            self.narrative_text,
            self.stats_text,
            self.resonance_text,
        ] + self.emotion_bars
    
    def run(self):
        """Start the visualization"""
        print("\n" + "=" * 60)
        print("RĀHIRI 2.0 - CYBER-ORGANIC BEING")
        print("=" * 60)
        print("\n  CONTROLS:")
        print("    ↑ ↓ ← →  : Move your avatar (cyan diamond)")
        print("    ESC      : Exit")
        print("\n  YOUR GOAL:")
        print("    Guide the entity. Build resonance through proximity.")
        print("    Watch how it responds to your presence.")
        print("\n" + "=" * 60)
        
        anim = FuncAnimation(
            self.fig,
            self.update,
            interval=self.config.frame_interval,
            blit=False,  # Safer rendering
            cache_frame_data=False
        )
        
        plt.show()


# =============================================================================
# MAIN
# =============================================================================

def main():
    """Entry point"""
    print("\n" + "=" * 60)
    print("RĀHIRI 2.0 - Cyber-Organic Visual Being")
    print("Complete Edition")
    print("=" * 60)
    
    try:
        # Check dependencies
        print("\n[SYSTEM] Checking dependencies...")
        print(f"  • NumPy: {np.__version__}")
        import matplotlib
        print(f"  • Matplotlib: {matplotlib.__version__}")
        
        # Create engine and visualizer
        print("\n[INIT] Creating cyber-organic entity...")
        engine = RahiriEngine()
        
        print("[INIT] Preparing visualization...")
        viz = Visualizer(engine)
        
        print("[LAUNCH] Starting simulation...\n")
        viz.run()
        
        print("\n[EXIT] Simulation ended.")
        return 0
        
    except KeyboardInterrupt:
        print("\n[EXIT] Interrupted by user.")
        return 0
    except Exception as e:
        print(f"\n[ERROR] {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main())
